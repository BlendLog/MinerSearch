<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="rktest" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\rktest.bin;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="_accept_en" xml:space="preserve">
    <value>Yes</value>
  </data>
  <data name="_accept_ru" xml:space="preserve">
    <value>Принять</value>
  </data>
  <data name="_AppAlreadyRunning_EN" xml:space="preserve">
    <value>Another copy of the application is already running. Display a help message?</value>
  </data>
  <data name="_AppAlreadyRunning_RU" xml:space="preserve">
    <value>Другая копия приложения уже запущена. Вывести сообщение справки?</value>
  </data>
  <data name="_ArchiveWarn_caption_en" xml:space="preserve">
    <value>Incorrect program startup</value>
  </data>
  <data name="_ArchiveWarn_caption_ru" xml:space="preserve">
    <value>Некорректный запуск программы</value>
  </data>
  <data name="_ArchiveWarn_en" xml:space="preserve">
    <value>The program was launched from the archive! Extract the entire archive and restart again.</value>
  </data>
  <data name="_ArchiveWarn_ru" xml:space="preserve">
    <value>Программа была запущена из архива! Извлеките весь архив и повторите перезапуск.</value>
  </data>
  <data name="_End_EN" xml:space="preserve">
    <value>All done! You can close this app.</value>
  </data>
  <data name="_End_RU" xml:space="preserve">
    <value>Готово! Приложение можно закрыть.</value>
  </data>
  <data name="_exit_en" xml:space="preserve">
    <value>No</value>
  </data>
  <data name="_exit_ru" xml:space="preserve">
    <value>Выйти</value>
  </data>
  <data name="_Help_EN" xml:space="preserve">
    <value>Startup params:

--help                        This help message
--no-logs                     Don't write logs in text file
--no-scantime                 Scan processes only
--no-runtime                  Static scan only (Malware dirs, files, registry keys, etc)
--no-services                 Skip scan services
--no-signature-scan           Skip scan files by signatures
--no-rootkit-check            Skip checking rootkit present
--depth=&lt;number&gt;              Where &lt;number&gt; specify the number for maximum search depth. Usage example --depth=5 (default 8)
--pause                       Pause before cleanup
--remove-empty-tasks          Delete a task from the Task Scheduler if the application file does not exist in it
--winpemode                   Start scanning in WinPE environment by specifying a different drive letter (without scanning processes, registry, firewall and task scheduler entries)
--scan-only                   Display malicious or suspicious objects, but do nothing
--full-scan                   Add other entire local drives for signature scan
--restore=&lt;path&gt;              Restore specified file from quarantine</value>
  </data>
  <data name="_Help_RU" xml:space="preserve">
    <value>Параметры запуска:

--help                       Вызов этой справки
--no-logs                    Не записывать лог в файл
--no-scantime                Сканировать только процессы
--no-runtime                 Не сканировать процессы (только каталоги, файлы, ключи реестра, и т.д.)
--no-services                Пропустить сканирование служб
--no-signature-scan          Пропустить сигнатурное сканирование файлов
--no-rootkit-check           Не проверять присутствие руткита
--depth=&lt;число&gt;              Где &lt;число&gt; - уровень максимальной глубины поиска. Пример использования --depth=5 (по-умолчанию 8)
--pause                      Пауза перед очисткой
--remove-empty-tasks         Удалять задачу из Планировщика задач, если файл приложения в ней не существует
--winpemode                  Запускает сканирование в режиме WinPE (без сканирования процессов, реестра, правил фаерволла, служб, задач планировщика)
--scan-only                  Отображать вредоносный или подозрительный объект, но не выполнять лечение
--full-scan                  Целиком добавляет другие локальные диски для сигнатурного сканирования
--restore=&lt;путь&gt;             Восстановить указанный файл из карантина</value>
  </data>
  <data name="_License_EN" xml:space="preserve">
    <value>Denial of responsibility

This software provided "as is" and was created exclusively to search and remove malware that secretly uses computer resources for mining cryptocurrency. The author is not responsible for incidental, indirect or unintentional damage of any kind during the use of this software. You may use it at your own risk.

FAQ:

Question: Why does my antivirus indicate that the software contains a Trojan/virus?
Answer: A third-party antivirus registers the very fact of interference in the system and cannot distinguish a specific action (change), which is what gives rise to such a reaction. It is impossible to clearly indicate that the action (change) being performed is performed for good purposes.

Question: The software closes during operation / freezes / does not start
Answer:
1) Third-party antivirus interferes with normal operation;
2) incorrect startup parameters / path too long / not installed / important components disabled;
3) Malicious software blocks its operation - in this case, you need to rename the executable file "MinerSearch_{version number}.exe" to anything else.
4) There was an error in the code that requires correction. Write about an error in an issue in the official github repository.

This license agreement applies to all copies, and to previous and subsequent versions of the software.

Are you sure you want to continue? 

Click Yes to continue. Click No to exit.</value>
  </data>
  <data name="_License_RU" xml:space="preserve">
    <value>Отказ от ответственности

Данное программное обеспечение (Далее ПО) предоставляется "как есть" и создано исключительно для поиска и удаления вредоносного ПО, тайно использующее ресурсы компьютера для добычи (майнинга) криптовалюты. Автор не несет ответсвенности за причиненный случайный, косвенный или непреднамеренный ущерб любого рода в ходе использования данного ПО. Вы можете использовать его на свой страх и риск. 

Часто задаваемые вопросы:

Вопрос: Почему мой антивирус указывает, что ПО содержит троян/вирус?
Ответ: Сторонний антивирус регистрирует сам факт вмешательства в систему и не может отличить конкретное действие (изменение), что как раз пораждает такую реакцию. Невозможно явно указать, что производимое действие (изменение) выполняется в благих целях. 

Вопрос: ПО закрывается во время работы / зависает / не запускается
Ответ: 
	1) Сторонний антивирус мешает нормальной работе;
	2) неверные параметры запуска / слишком длинный путь / не установлены / отключены важные компоненты;
	3) Вредоносное ПО блокирует его работу - в таком случае необходимо переименовать исполняемый файл "MinerSearch_{номер-версии}.exe" в любое другое.
	4) В коде была допущена ошибка, которая требует исправления. Об ошибке писать в issue в официальный репозиторий github. 

Настоящее лицензионное соглашение распространяется на все копии, а также на предыдущие и последующие версии программного обеспечения.

Вы уверены, что хотите продолжить?

Нажмите "Принять" - чтобы подолжить. Нажмите "Выйти" - чтобы закрыть программу. </value>
  </data>
</root>